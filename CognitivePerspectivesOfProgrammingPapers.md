A list of papers that examined programming with the lens of cognitive science
=============================================================================

### How do we approach this problem?
* [ON THE COGNITIVE PREREQUISITES OF LEARNING COMPUTER PROGRAMMING](https://web.stanford.edu/~roypea/RoyPDF%20folder/A17_Pea_Kurland_83.pdf)
  - Study on the cognitive perspective of programming started back in 1950s. However, after three decades, the studies still focused on what aptitute variables correlate with programming skills. This paper tried to approach this problem from a more fundamental perspective.
  - What factors may affect the programming performance is highly-dependent on the goal of programming. For example, if a program is not user-facing, then documenting it and the corresponding mental skills required are not necessary.
  - There were roughly four levels of expertise of programming, and they are listed below in the ascending order with respect to expertise: program user, code generator, program generator, software developer. The major difference between program generators and software developers is that software developers can develop a program that is intended to be used by other people. Software developers can not only build sophisticated logic, but are also good at documenting, debugging, writing tests for the program, doing optimization, simulating how the program runs in the brain, designing the app before implementing it, and they usually draw on libraries and programming utilities to reduce development time.
  - Characteristics of programming skills:
  - A difference in what the perceived structure of program is between novice and experienced programmers have been identified.
    - For novice developers, the most programs were constructed from a small set of basic program schemas comparable to the "plan library" of Schrobe et al.
    - For "experts", they saw whole blocks of code as "instantiations" of well-known problems such as calculating change.
  - A large number of component rules underlied an experts' generation of programming problem solutions
  - the ability to construct detailed mental models of how the computer is functioning when a computer program is running.
  - Experts have advantages in short-term memory for meaningful chunks of information compared to novices. The classific findings from the studies of chess players were repeatedly replicated for the domain of computer programming.
    - experts clustered keywords based on the meanings in a language (ALGOL), while novices clustered them based on surface ordinary language associations.
  - Expert developers debug their programs in different ways than novices. Program debugging involves comprehension processes analogous to those for reading ordnary language prose. Experts read programs for flow of control (execution), rather than line by line (as text).
  - Theories of cognitive subtasks in programming:
    -  They maybe summarized as: (1) understanding the programming problem; (2) designing or planning a programming solution; (3) writing a programming code that implements the plan; and (4) comprehension of the written program and program debugging.
  - Understanding the problem: set up some form of problem representation in the working memory initially
  - Designing and planning: planning-in-action vs. preplanning; plans are highly hierarchical.
    - There are four basic types of program information: 1) the purpose/function of a particular plan unit; 2) the structure of the data objects; 3) the sequencing of operations (control flow); 4) the transformation of data objects (data flow)
    - 6 knowledge schemas are discussed
    - symbolic execution plays an important role
  - Program coding: (1) ability to engage in hypothetical symbolic execution of code; (2) ability to learn the coding templates that define the syntactical knowledge necessary for code generation : and
(3) *ability to keep to the goal at hand, or program plan, unless deviations from it are required to generate the code*
  - program debugging:
    - program understanding is mediated by a hierarchical representation of three levels: (1) deep plans (purpose); (2) surface plans (in program structure); and (3) definitions of data objects, properties, and 110 specifications for program code segments.
  - Some factors influence programming skill development:
    - Similarly, one characteristic of expert programmers (Kurland & Pea, in preparation) is they know many different lan- guages. For any particular programming job, they tend to select the language best suited for that application taking into account the specific machine and operating environment in which they will be working.
    - The lesson to be learned is that the speafic language chosen probably does not make a big difference, at least for adults. Far more important in carrying the variance for computer programming expertise are issues such as the resources that are available in the programming environment, how programming instruction occurs, and the amount of program writing, reading, and debugging students engage in.
    - How much instructions, if any, is the best when introducing children to computer programming? There were two extremes. One extreme was to give them detailed instructions on a set of computer programming constructs to build a set of sample programs. The other extreme is to give little instruction but to encourage them to explore possibilities, which is called the "enlightenment idea" (popularized by Papert (1980) in his book Mindstorm).
    - In contrast to highly skilled programmers, as many adults learn to program they reveal deep misunderstandings of computer programming concepts and how different lines of programming code relate to one another in program organization (Bonar & Soloway, 1982; Jeffries, 1982; Sheil, 1980, 1981a; Soloway, Bonar & Ehrlich, 1983; Soloway, Ehrlich, Bonar & Greenspan, 1982)
  - What knowledge is required for programming?
    - Only anecdotal evidence is available. Prior research has suffered from biases.
    - Even a student who aspires only to be a programmer needs more than just programming skills. He or she needs to understand issues of design, of the capability and potential of software, hardware, and theory, and of algorithms and information organization in general.
    - What are some of the most plausible a priori candidates for cognitive demands of programming? While no research has been directly aimed at defining the cognitive prerequisites for learning computer programming (it has asked who will do it better, predictively, rather than who can do it at all), at least five factors have been mentioned frequently: (1) mathematical ability, (2) memory capacity, ( 3 ) analogical reasoning skills, (4) con- ditional reasoning skills, and (5) procedural thinking skills. These cognitive abilities are presumed to have an impact on or to mediate computer programming learning in a number of ways.
  - Multiple types of programming: system programming, application programming, diagnostic programming, program maintenance
  - Multiple types of programmers: (1) professional programmers; (2) occasional programmers; and (3) programmer hobbyists.
  - Different evaluation criteria with respect to different kinds of programming: In industry1 business, the emphasis is on rapid programming; in games, compact code; in some educational software, developmental structure of materi- als and problems. Personal programming may be workable, buggy, undocumented, and unreliable for some inputs which might be entered if other people were to use the program...
  - Collaborative environment
- Programming aptitude measurement
  - Although most studies in whish programming aptitude test scores correlated significantly with programming "ssucess"(general1y indi- cated by grades in industrial programming training courses or college programming courses) o-bserved that "general intelligence'! (when test scores were available) also correlated very highly with programming success, this does not seem to have moved the researchers to go further and ask whether the "programming aptitude" supposedly linked to programming skill constituted a specific aptitude factor above and beyond "general intelligence.
- Programming aptitude prediction
  - deductive reasoning ability
  - problem-solving style:
    - there is a significant correlation between field independence and success ina college COBOL programming course.
    - there is a significant correlation between the score of a BASIC programming examination and "analytic" as opposed to "heuristic" cognitive style. Cheney suggests that those scor- ing highly on the style measure, and presumed to be "analytic," may learn programming best by progressing at their own rate on program- ming projects, but that the "heuristic" thinkers may require more structured and formal teaching to understand how to program.
    - These cognitive style differences do not explain the differences of program skills, aka the different performance pertaining to the cognitive subtasks for programming. They do offer suggestions that cognitive style interacts with how one is taught programming.
  - [](https://s3.amazonaws.com/academia.edu.documents/30981043/10.1.1.54.3584.pdf?AWSAccessKeyId=AKIAIWOWYYGZ2Y53UL3A&Expires=1526594714&Signature=4G453kFWjrwXiURlJwzy52tOWww%3D&response-content-disposition=inline%3B%20filename%3DUsability_Analysis_of_Visual_Programming.pdf)
    - Mental representations
    - Order of program development
    - Effect of environment
    - From problem to program
      - inherent goal vs planning goal
    - Understanding and evaluating the program

### Studying the cognitive process of programming using eye tracking
* [An eye-tracking methodology for characterizing program comprehension processes](https://www.tandfonline.com/doi/abs/10.1080/00011037.1980.11008282)
* [Comparison of Three Eye Tracking Devices in Psychology of Programming Research](http://www.cs.joensuu.fi/~saja/var_roles/abstracts/ppig04_ne_sa.pdf)

### Cognitive style and programming

### Expert and novice developers have different performance if programming tasks, because:
  - Different skills to comprehend the program behavior without running it.
    - [Debugging by skilled and novice programmers](https://dl.acm.org/citation.cfm?id=22367)

### The implications of the various choices of information sources (stack overflow, opensource movement, libraries)
  - Is there a shift of focus from planning for developmeng to finding the right information sources and the right assistive tools or libraries to achieve the goal?

### The implications of the change of focus: developers today need to consider issues that were less of a concern in the past, such as privacy.

### Similar to the previous one, the programming goal is also changing.
  - Exploratory programming [Variolite: Supporting Exploratory Programming by Data Scientists](http://marybethkery.com/resources/Papers/variolite-supporting-exploratory-programming.pdf)
  - Opportunistic programming [Opportunistic Programming: How Rapid Ideation and Prototyping Occur in Practice
Joel](http://hci.stanford.edu/publications/2008/brandt_weuse08.pdf)
    - Lacks an explicit program designing and planning stage. I have the following intuition that the approach that many developers may employ today is to directly search their goal, and actively seek code examples in the results. Then they will read and try to comprehend the examples, and try to adapt them to their needs.
    - However, this may cause some trouble, such as introducing security breaches when reuse code from Q&A sites.
  - One data point suggests that when programmers are learning new libraries, as much as one-third of their code is directly taken from examples in documentation [Designing interactions that combine pen, paper, and computer](https://dl.acm.org/citation.cfm?id=1369304)
### Knowledge organization
  - [Knowledge Organization and Skill Differences in Computer Programmers](http://spider.sci.brooklyn.cuny.edu/~kopec/research/sdarticle11.pdf) Expert developers not only have more information, they also better organize this information into useful chunks. Begninner developers organize information based on langauge associations, while expert developers organize information based on programming language knowledge.
